<!DOCTYPE html>
<html>
<head>
  <title>Bike Route Visualization</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
  <script>
    console.log("Script started.");

    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.set(0, 0, 10); // Initial camera position
    controls.update();

    // Helpers for debugging
    const gridHelper = new THREE.GridHelper(10, 10);
    scene.add(gridHelper);
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    // Constants for converting degrees to meters (approximate for Brussels latitude)
    const METERS_PER_DEGREE_LAT = 111320; // Approx at equator
    const METERS_PER_DEGREE_LON = 111320 * Math.cos(50.83 * Math.PI / 180); // Approx at Brussels latitude

    // Load the route data
    console.log("Fetching route.geojson...");
    fetch('route.geojson')
      .then(response => {
        console.log("Fetch response received.");
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        console.log("GeoJSON data parsed:", data);

        if (!data.features || data.features.length === 0) {
            console.error("GeoJSON has no features.");
            return;
        }

        const group = new THREE.Group();
        const material = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 5 });

        // 1. Find the overall bounding box for X, Y, and Z in meters
        const overallBboxMeters = new THREE.Box3();
        let totalElevation = 0;
        let elevationCount = 0;

        for (const feature of data.features) {
            if (feature.geometry && feature.geometry.coordinates) {
                for (const coord of feature.geometry.coordinates) {
                    const xMeters = coord[0] * METERS_PER_DEGREE_LON;
                    const yMeters = coord[1] * METERS_PER_DEGREE_LAT;
                    const zMeters = coord[2] || 0;

                    overallBboxMeters.expandByPoint(new THREE.Vector3(xMeters, yMeters, zMeters));

                    if (typeof coord[2] === 'number' && !isNaN(coord[2])) {
                        totalElevation += coord[2];
                        elevationCount++;
                    }
                }
            }
        }
        const overallCenterMeters = overallBboxMeters.getCenter(new THREE.Vector3());
        const avgElevation = elevationCount > 0 ? totalElevation / elevationCount : 0;

        console.log("Overall Bounding Box (Meters):", overallBboxMeters);
        console.log("Overall Center (Meters):", overallCenterMeters);
        console.log("Average Elevation:", avgElevation);

        const verticalExaggeration = 5; // Adjust this value to exaggerate vertical scale

        // Calculate a single scaling factor for the entire route in meters
        const sizeMeters = overallBboxMeters.getSize(new THREE.Vector3());
        const maxDimMeters = Math.max(sizeMeters.x, sizeMeters.y, sizeMeters.z * verticalExaggeration); // Consider exaggerated Z
        const globalScaleFactor = maxDimMeters > 0 ? 10 / maxDimMeters : 1; // Scale to fit within a 10-unit cube

        console.log("Size (Meters):", sizeMeters);
        console.log("Max Dimension (Meters, with exaggerated Z):", maxDimMeters);
        console.log("Global Scale Factor:", globalScaleFactor);

        // 2. Create the geometries with normalized and scaled coordinates
        for (const feature of data.features) {
            if (!feature.geometry || !feature.geometry.coordinates) continue;

            const points = feature.geometry.coordinates.map(coord => {
                // Convert to meters, center, and apply global scale
                const x = (coord[0] * METERS_PER_DEGREE_LON - overallCenterMeters.x) * globalScaleFactor;
                const y = (coord[1] * METERS_PER_DEGREE_LAT - overallCenterMeters.y) * globalScaleFactor;

                // Normalize Z, apply exaggeration, and then global scale
                let z = (coord[2] || 0) - overallCenterMeters.z;
                z = (z * verticalExaggeration) * globalScaleFactor; 

                return new THREE.Vector3(x, y, z);
            });
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            group.add(line);
        }

        scene.add(group);

      })
      .catch(error => {
        console.error('Error loading or processing GeoJSON:', error);
      });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }, false);

  </script>
</body>
</html>